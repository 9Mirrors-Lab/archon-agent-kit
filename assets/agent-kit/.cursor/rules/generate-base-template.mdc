
# Generate Base PRP Template Rule

## Purpose

This rule generates technology-specific base PRP templates (`prp-base-{tech}.json` and `prp-base-{tech}.md`) from `PRPs/INITIAL.md` files. It uses the embedded canonical template and overlays tech-specific content for **project-wide implementation**.

## Core Workflow

**Input**: `PRPs/INITIAL.md` with project context (+ Project Name)
**Output (Local)**: 
- `PRPs/templates/prp-base-{tech}.json` (technology-specific base PRP as JSON)
- `PRPs/templates/prp-base-{tech}.md` (technology-specific base PRP as Markdown)
**Method**: Use embedded canonical template + overlay tech-specific content + write local JSON and Markdown files
**Note**: This rule does NOT create Archon documents - it only generates local base templates

## Canonical Template

The following is the embedded canonical PRP template that provides the complete schema structure:

```json
{
  "document_type": "prp",
  "title": "Project Implementation PRP",
  "version": "1.0",
  "author": "prp-creator",
  "date": "${YYYY-MM-DD}",
  "status": "draft",
  
  "goal": "Implement complete project with all planned features and capabilities",
  
  "why": [
    "Business value of the entire project",
    "Integration benefits across all features",
    "Strategic importance of complete system",
    "Reduce regressions via explicit validation loops"
  ],
  
  "what": {
    "description": "Complete project scope with all planned features and capabilities",
    "success_criteria": [
      "All planned features implemented and integrated",
      "End-to-end workflows functional across features",
      "Performance and security requirements met for entire system",
      "All validation gates pass successfully"
    ],
    "user_stories": [
      "As a [user type], I want to [action] so that [benefit]",
      "As a [user type], I need to [requirement] in order to [goal]"
    ]
  },
  
  "context": {
    "documentation": [
      {
        "source": "https://docs.example.com/api",
        "why": "API endpoints and data models needed"
      },
      {
        "source": "src/components/Example.tsx",
        "why": "Existing pattern to follow for UI components"
      }
    ],
    "existing_code": [
      {
        "file": "src/services/baseService.ts",
        "purpose": "Service layer pattern to extend"
      }
    ],
    "gotchas": [
      "Critical requirement or constraint to remember",
      "Common mistake to avoid during implementation",
      "Avoid unvalidated input; always validate on server",
      "Do not put secrets in client bundles",
      "No blocking data fetch in large client components",
      "Authentication must be implemented before protected features",
      "Database migrations must handle all planned tables",
      "Frontend components must follow consistent design patterns"
    ],
    "principles": [
      "Context is King: Include ALL necessary documentation and examples",
      "Validation Loops: Provide executable tests the AI can run and fix",
      "Information Dense: Use keywords and patterns from the codebase",
      "Progressive Success: Start simple, validate, then enhance",
      "Feature Integration: Plan how features work together",
      "Dependency Management: Clear understanding of build order"
    ],
    "current_tree": ".\n├── src/\n│   ├── components/\n│   ├── services/\n│   └── api/\n├── tests/\n└── docs/",
    "desired_tree": ".\n├── src/\n│   ├── components/\n│   │   ├── Feature1/\n│   │   ├── Feature2/\n│   │   └── Feature3/\n│   ├── services/\n│   │   ├── feature1Service.ts\n│   │   ├── feature2Service.ts\n│   │   └── feature3Service.ts\n│   ├── api/\n│   │   ├── feature1/\n│   │   ├── feature2/\n│   │   └── feature3/\n│   └── types/\n│       ├── feature1.ts\n│       ├── feature2.ts\n│       └── feature3.ts\n├── tests/\n│   ├── feature1.test.ts\n│   ├── feature2.test.ts\n│   └── feature3.test.ts\n└── docs/\n    ├── feature1.md\n    ├── feature2.md\n    └── feature3.md",
    "dependencies": [
      "Package or service that must be available",
      "Another feature that must be completed first"
    ],
    "environment_variables": [
      "API_KEY",
      "DATABASE_URL",
      "FEATURE_FLAG_ENABLED"
    ],
    "config_notes": [
      "Use .env.local; never commit secrets",
      "Feature flags for gradual rollout"
    ]
  },
  
  "implementation_blueprint": {
    "phase_1_foundation": {
      "description": "Core infrastructure and shared components",
      "duration": "1-2 weeks",
      "features": [
        {
          "name": "Core Infrastructure",
          "epic_description": "Foundation that all other features build upon",
          "user_stories": [
            "US-001: System setup and configuration",
            "US-002: Database schema and models",
            "US-003: Authentication and authorization"
          ],
          "tasks": [
            {
              "title": "Core Infrastructure: Set up project structure",
              "feature": "Core Infrastructure",
              "details": "Create base project structure with shared components",
              "files": ["src/config/", "src/utils/", "src/types/base.ts"]
            },
            {
              "title": "Core Infrastructure: Database setup",
              "feature": "Core Infrastructure", 
              "details": "Initialize database with core schemas",
              "files": ["migrations/001_initial_schema.sql", "src/models/base.py"]
            }
          ]
        }
      ]
    },
    "phase_2_core_features": {
      "description": "Primary business functionality",
      "duration": "2-3 weeks",
      "features": [
        {
          "name": "Feature 1",
          "epic_description": "Primary business feature description",
          "user_stories": [
            "US-004: Core functionality user story",
            "US-005: Advanced functionality user story"
          ],
          "tasks": [
            {
              "title": "Feature 1: Implement core functionality",
              "feature": "Feature 1",
              "details": "Build primary business logic and API endpoints",
              "files": ["src/services/feature1Service.ts", "src/api/feature1/"]
            }
          ]
        },
        {
          "name": "Feature 2",
          "epic_description": "Secondary business feature description",
          "user_stories": [
            "US-006: Secondary functionality user story"
          ],
          "tasks": [
            {
              "title": "Feature 2: Implement secondary functionality",
              "feature": "Feature 2",
              "details": "Build secondary business logic and integration",
              "files": ["src/services/feature2Service.ts", "src/api/feature2/"]
            }
          ]
        }
      ]
    },
    "phase_3_integration": {
      "description": "Feature integration and end-to-end workflows",
      "duration": "1-2 weeks",
      "features": [
        {
          "name": "System Integration",
          "epic_description": "Connect all features into cohesive system",
          "user_stories": [
            "US-007: Cross-feature workflow",
            "US-008: System-wide validation"
          ],
          "tasks": [
            {
              "title": "System Integration: Connect features",
              "feature": "System Integration",
              "details": "Implement cross-feature communication and workflows",
              "files": ["src/services/integrationService.ts", "src/workflows/"]
            }
          ]
        }
      ]
    }
  },
  
  "validation": {
    "level_1_syntax": [
      "npm run lint -- --fix",
      "npm run typecheck",
      "Ensure no TypeScript errors",
      "ruff check src/ --fix",
      "mypy src/"
    ],
    "level_2_unit_tests": [
      "npm run test -- --coverage",
      "Verify all unit tests pass with >80% coverage",
      "uv run pytest tests/ -v --cov=src"
    ],
    "level_3_integration": [
      "npm run test:integration",
      "Test API endpoints with proper data flow",
      "uv run pytest tests/integration/ -v"
    ],
    "level_4_end_to_end": [
      "Start development server and test user flows",
      "Verify feature works as expected in browser",
      "Test error scenarios and edge cases",
      "uv run pytest tests/e2e/ -v"
    ],
    "final_checklist": [
      "All lint/type checks pass",
      "Critical user flows tested E2E",
      "Empty states and error states handled",
      "Performance benchmarks met",
      "Security considerations addressed",
      "All features integrated and working together"
    ],
    "summary": {
      "confidence_score": "8/10",
      "notes": "High confidence with comprehensive validation gates, clear implementation phases, and feature integration planning"
    }
  }
}
```

## Technology Detection Logic

### 1. Framework Detection
**Scan for mentions of:**
- **Frontend**: React, Next.js, Vue, Svelte, Remix, Angular
- **Backend**: FastAPI, Express, Django, Flask, Spring, .NET
- **Mobile**: React Native, Flutter, Swift, Kotlin
- **CLI**: Click, Typer, Commander, argparse, clap
- **Database**: PostgreSQL, MongoDB, Redis, SQLite, Prisma, Drizzle

### 2. Documentation URL Detection
**Extract tech from URLs:**
- `supabase.com/docs` → Supabase
- `nextjs.org/docs` → Next.js
- `docs.python.org` → Python
- `docs.rs` → Rust
- `developer.mozilla.org` → Web technologies

### 3. File Path Pattern Detection
**Infer tech from examples:**
- `app/page.tsx` → Next.js App Router
- `src/main.rs` → Rust
- `src/main.py` → Python
- `src/App.jsx` → React
- `src/components/` → Component-based framework

## Template Structure

### Layer 1: Universal (Always Included)

#### 4-Level Validation Loop
```markdown
## Validation Loop

### Level 1: Syntax & Style
- [ ] Ruff linting and formatting
- [ ] MyPy type checking (if applicable)
- [ ] ESLint/Prettier (if applicable)
- [ ] Zero errors before proceeding

### Level 2: Unit Tests
- [ ] Test each component as created
- [ ] Follow existing test patterns
- [ ] Full coverage of public methods
- [ ] Mock external dependencies

### Level 3: Integration Testing
- [ ] Service startup validation
- [ ] Endpoint testing
- [ ] Database connectivity
- [ ] MCP tool validation
- [ ] Cross-component communication
- [ ] Feature integration testing

### Level 4: Creative Validation
- [ ] Domain-specific testing
- [ ] Performance validation
- [ ] Security scanning
- [ ] Load testing if applicable
- [ ] User experience validation
- [ ] End-to-end workflow validation
```

#### Patterns and Gotchas
```markdown
## Patterns and Gotchas

### Common Patterns
- [Pattern description with file path reference]
- [Implementation example]
- [When to use this pattern]

### Known Gotchas
- [Common pitfall description]
- [Why it happens]
- [How to avoid it]
- [Alternative approaches]
```

#### Anti-Patterns
```markdown
## Anti-Patterns to Avoid

### ❌ Never Do This
- [Anti-pattern description]
- [Why it's problematic]
- [What to do instead]

### ❌ Common Mistakes
- [Mistake description]
- [Impact on system]
- [Correct approach]
```

### Layer 2: Archon-Specific

#### Project Structure Templates
```markdown
## Desired Codebase Tree with Files to Add

### Current State
```
[Current file tree from INITIAL.md analysis]
```

### Target State
```
[Desired file tree with all planned features and files highlighted]
```

### File Naming Conventions
- **Models**: `snake_case` for Python, `PascalCase` for TypeScript
- **Services**: `snake_case` for Python, `camelCase` for TypeScript
- **Components**: `PascalCase` for React/Vue components
- **Utilities**: `snake_case` for Python, `camelCase` for TypeScript
- **Tests**: `test_*.py` for Python, `*.test.ts` for TypeScript
```

#### Known Gotchas of Our Codebase
```markdown
## Known Gotchas of Our Codebase

### Architecture Constraints
- [Specific limitation or constraint]
- [Why it exists]
- [How to work around it]

### Integration Points
- [MCP tool integration requirement]
- [Database connection pattern]
- [External service integration]
- [Error handling approach]
- [Feature integration patterns]
```

## Implementation Steps

### Step 1: Resolve Project and Parse INITIAL.md
```bash
# Resolve project name:
# Priority: (a) second CLI arg to this rule, (b) parse from INITIAL.md (e.g., "Project Name:"), (c) fail with instruction to supply project name

# Ensure Archon project exists and capture project_id
# 1) Try to find by title, else create
archon:manage_project(action="list")
#   - find project where title == {project_name}
#   - if not found → archon:manage_project(action="create", title="{project_name}")
#   - capture {project_id}

# Analyze INITIAL.md from PRPs folder
archon:perform_rag_query(query="technology frameworks tools", source="PRPs/INITIAL.md")
archon:search_code_examples(query="file structure patterns", source="PRPs/INITIAL.md")
```

### Step 2: Use Embedded Canonical Template
```bash
# Use the embedded canonical template above as the base structure
# This provides the complete schema structure with project-wide support
# No need to load external files - template is embedded in this rule
```

### Step 3: Detect Technology Stack
```bash
# Analyze content for technology indicators
# Extract framework mentions, documentation URLs, file patterns
# Determine primary technology for template naming
```

### Step 4: Overlay Tech-Specific Content
```bash
# Update these sections with tech-specific content:
# - goal: Tailored to detected technology for complete project
# - why: Technology-specific benefits for entire system
# - what.description: Complete project scope for the technology
# - what.success_criteria: Tech-appropriate metrics for all features
# - what.user_stories: Technology-specific user scenarios across features
# - context.documentation: Official docs for all planned technologies
# - context.gotchas: Common pitfalls for the technology stack
# - context.dependencies: All required packages and services
# - context.environment_variables: Tech-specific env vars for complete system
# - implementation_blueprint: Technology-appropriate phases with feature breakdown
# - validation: Tech-specific lint/test/validation commands for entire project
```

### Step 5: Save Local Templates
```bash
# Write to: PRPs/templates/prp-base-{detected_tech}.json (JSON version)
# Write to: PRPs/templates/prp-base-{detected_tech}.md (Markdown version)
# Do NOT upload to Archon - this is just a local template
```

## Tech-Specific Content Overlays

### Next.js Overlay (Project-Wide)
```json
{
  "goal": "Build complete Next.js application with all planned features using App Router, typed APIs, and secure defaults across the entire system.",
  "why": [
    "Leverage React Server Components for performance and simplicity across all features",
    "Standardize data fetching and validation across all pages and routes",
    "Ensure secure, scalable defaults aligned with Vercel/Next best practices",
    "Enable feature integration through consistent patterns and shared components"
  ],
  "context": {
    "documentation": [
      {"source": "https://nextjs.org/docs", "why": "Core framework guidance for all features"},
      {"source": "https://zod.dev/", "why": "Schema validation across the application"},
      {"source": "https://tailwindcss.com/docs", "why": "Consistent styling across all components"}
    ],
    "gotchas": [
      "Use 'use client' only when necessary - affects all features",
      "Avoid dynamic rendering where static/ISR suffices",
      "Validate request data at the edge of route handlers with zod",
      "Shared state management affects all features - plan carefully",
      "Component library consistency across all features"
    ],
    "dependencies": ["next", "react", "react-dom", "zod", "@tanstack/react-query", "tailwindcss"],
    "environment_variables": ["NEXT_PUBLIC_API_URL", "NODE_ENV", "NEXT_PUBLIC_FEATURE_FLAGS"]
  },
  "implementation_blueprint": {
    "phase_1_foundation": {
      "description": "Core Next.js infrastructure and shared components",
      "features": [
        {
          "name": "Core Infrastructure",
          "epic_description": "Foundation that all other features build upon",
          "user_stories": ["US-001: Project setup", "US-002: Shared components", "US-003: Base layouts"],
          "tasks": [
            {
              "title": "Core Infrastructure: Set up Next.js project structure",
              "feature": "Core Infrastructure",
              "details": "Initialize Next.js with App Router and shared components",
              "files": ["src/app/layout.tsx", "src/components/ui/", "src/lib/utils.ts"]
            }
          ]
        }
      ]
    },
    "phase_2_core_features": {
      "description": "Primary business functionality",
      "features": [
        {
          "name": "Feature 1",
          "epic_description": "Primary business feature with Next.js patterns",
          "user_stories": ["US-004: Core functionality", "US-005: Advanced functionality"],
          "tasks": [
            {
              "title": "Feature 1: Implement with Next.js patterns",
              "feature": "Feature 1",
              "details": "Build feature using App Router, Server Components, and shared patterns",
              "files": ["src/app/feature1/", "src/components/feature1/", "src/lib/feature1.ts"]
            }
          ]
        }
      ]
    }
  },
  "validation": {
    "level_1_syntax": ["pnpm lint", "pnpm type-check", "pnpm format"],
    "level_2_unit_tests": ["pnpm test", "pnpm test:coverage"],
    "level_3_integration": ["pnpm next build && pnpm next start -p 4000", "pnpm test:integration"],
    "level_4_end_to_end": ["Lighthouse pass >= 90", "Basic security headers present", "Feature integration tests pass"]
  }
}
```

### FastAPI Overlay (Project-Wide)
```json
{
  "goal": "Deliver complete FastAPI system with all planned features, typed models, modular routers, and resilient HTTP clients across the entire application.",
  "why": [
    "Fast developer feedback loops with Python typing and Pydantic across all features",
    "Clear separation of routers, services, and schemas for maintainable codebase",
    "First-class async support for performance across all endpoints",
    "Consistent patterns enable feature integration and system-wide validation"
  ],
  "context": {
    "documentation": [
      {"source": "https://fastapi.tiangolo.com/", "why": "Framework docs for all API features"},
      {"source": "https://docs.pydantic.dev/", "why": "Data validation across all models"},
      {"source": "https://docs.sqlalchemy.org/", "why": "Database patterns for all features"}
    ],
    "gotchas": [
      "Use async def for I/O-bound endpoints across all features",
      "Close HTTP clients (httpx.AsyncClient) properly",
      "Return JSON-serializable models only",
      "Database session management affects all features",
      "Shared middleware and dependencies impact entire system"
    ],
    "dependencies": ["fastapi", "uvicorn[standard]", "pydantic", "httpx", "pytest", "pytest-asyncio", "sqlalchemy"],
    "environment_variables": ["PORT", "DATABASE_URL", "ENV", "API_KEYS", "FEATURE_FLAGS"]
  },
  "implementation_blueprint": {
    "phase_1_foundation": {
      "description": "Core FastAPI infrastructure and shared components",
      "features": [
        {
          "name": "Core Infrastructure",
          "epic_description": "Foundation that all other features build upon",
          "user_stories": ["US-001: FastAPI setup", "US-002: Database models", "US-003: Authentication"],
          "tasks": [
            {
              "title": "Core Infrastructure: Set up FastAPI project structure",
              "feature": "Core Infrastructure",
              "details": "Initialize FastAPI with shared middleware, models, and database setup",
              "files": ["src/main.py", "src/models/base.py", "src/database/", "src/middleware/"]
            }
          ]
        }
      ]
    },
    "phase_2_core_features": {
      "description": "Primary business functionality",
      "features": [
        {
          "name": "Feature 1",
          "epic_description": "Primary business feature with FastAPI patterns",
          "user_stories": ["US-004: Core functionality", "US-005: Advanced functionality"],
          "tasks": [
            {
              "title": "Feature 1: Implement with FastAPI patterns",
              "feature": "Feature 1",
              "details": "Build feature using routers, services, and shared patterns",
              "files": ["src/api/feature1/", "src/services/feature1_service.py", "src/models/feature1.py"]
            }
          ]
        }
      ]
    }
  },
  "validation": {
    "level_1_syntax": ["ruff check .", "mypy .", "ruff format ."],
    "level_2_unit_tests": ["pytest -q", "pytest --cov=src"],
    "level_3_integration": ["uvicorn app.main:app --port 8000 & sleep 2 && curl -f http://localhost:8000/healthz"],
    "level_4_end_to_end": ["ab or hey load test all endpoints", "security scan dependencies", "Feature integration tests"]
  }
}
```

### Express Overlay (Project-Wide)
```json
{
  "goal": "Build complete Express.js system with all planned features, secure middleware, zod-validated routes, and modern logging across the entire application.",
  "why": [
    "Fast baseline API with wide ecosystem support for all features",
    "Explicit validation and error mapping for reliability across the system",
    "Security headers and sane defaults from day one for all endpoints",
    "Consistent patterns enable feature integration and maintainable codebase"
  ],
  "context": {
    "documentation": [
      {"source": "https://expressjs.com/", "why": "Framework docs for all API features"},
      {"source": "https://github.com/colinhacks/zod", "why": "Validation across all routes"},
      {"source": "https://www.prisma.io/docs", "why": "Database patterns for all features"}
    ],
    "gotchas": [
      "Order of middleware matters (security first) - affects all routes",
      "Never trust req.body without validation",
      "Return consistent error shape across all endpoints",
      "Shared middleware impacts entire system",
      "Database connection management affects all features"
    ],
    "dependencies": ["express", "zod", "helmet", "cors", "pino", "pino-http", "prisma", "jest"],
    "environment_variables": ["PORT", "NODE_ENV", "DATABASE_URL", "API_KEYS", "FEATURE_FLAGS"]
  },
  "implementation_blueprint": {
    "phase_1_foundation": {
      "description": "Core Express.js infrastructure and shared components",
      "features": [
        {
          "name": "Core Infrastructure",
          "epic_description": "Foundation that all other features build upon",
          "user_stories": ["US-001: Express setup", "US-002: Database models", "US-003: Authentication"],
          "tasks": [
            {
              "title": "Core Infrastructure: Set up Express.js project structure",
              "feature": "Core Infrastructure",
              "details": "Initialize Express with shared middleware, models, and database setup",
              "files": ["src/server.js", "src/models/", "src/middleware/", "src/config/"]
            }
          ]
        }
      ]
    },
    "phase_2_core_features": {
      "description": "Primary business functionality",
      "features": [
        {
          "name": "Feature 1",
          "epic_description": "Primary business feature with Express patterns",
          "user_stories": ["US-004: Core functionality", "US-005: Advanced functionality"],
          "tasks": [
            {
              "title": "Feature 1: Implement with Express patterns",
              "feature": "Feature 1",
              "details": "Build feature using routers, services, and shared patterns",
              "files": ["src/routes/feature1/", "src/services/feature1Service.js", "src/models/feature1.js"]
            }
          ]
        }
      ]
    }
  },
  "validation": {
    "level_1_syntax": ["npm run lint", "npm run type-check", "npm run format"],
    "level_2_unit_tests": ["npm test", "npm run test:coverage"],
    "level_3_integration": ["node dist/server.js & sleep 2 && curl -f http://localhost:${PORT:-3000}/health"],
    "level_4_end_to_end": ["k6 or artillery load test all endpoints", "security header scan", "Feature integration tests"]
  }
}
```

## Output Generation

### JSON Version
Generate `prp-base-{tech}.json` with the complete structured PRP content following the canonical template schema.

### Markdown Version
Generate `prp-base-{tech}.md` with the same content formatted as readable markdown:

```markdown
# Base Template - {DetectedTech}

## Goal
[Technology-specific goal from JSON]

## Why
[Technology-specific benefits from JSON]

## What
[Technology-specific description and success criteria from JSON]

## Context
[Technology-specific context, documentation, and gotchas from JSON]

## Implementation Blueprint
[Technology-specific implementation phases and features from JSON]

## Validation
[Technology-specific validation steps from JSON]
```

## MCP Upload Format

When ready to upload the generated base template to Archon, use this format:

```json
{
  "tool": "manage_document",
  "args": {
    "action": "add",
    "project_id": "<PROJECT_ID>",
    "document_type": "prp",
    "title": "Base Template - {DetectedTech}",
    "content": {
      // The complete generated prp-base-{tech}.json content goes here
      "document_type": "prp",
      "title": "Base Template - {DetectedTech}",
      "version": "1.0",
      "author": "prp-creator",
      "date": "2025-08-20",
      "status": "draft",
      "goal": "...",
      "why": [...],
      "what": {...},
      "context": {...},
      "implementation_blueprint": {...},
      "validation": {...}
    },
    "metadata": { "author": "prp-creator", "tags": ["base-template", "prp"] }
  }
}
```

## Notes

- The canonical template is embedded directly in this rule for immediate access
- Only overlay tech-specific content in the allowed sections
- Generate both JSON and Markdown versions for flexibility
- This generates local templates only - no Archon integration at this stage
- For Archon upload, use the MCP format above
- **Project-wide approach**: All tech overlays now include feature-based implementation blueprints
- **Feature integration**: Tech overlays emphasize how features work together within the technology stack
- **Dual output**: Generate both structured JSON and readable Markdown versions
- **PRP folder structure**: Expects INITIAL.md to be in the PRP folder as per installation structure
- **Embedded template**: No external file dependencies - template is self-contained